\documentclass[../../main.tex]{subfiles}

\begin{document}
\subsection{Quantum Monte Carlo}\label{sec: qmc}
Quantum Amplitude Estimation provides a quadratic speed-up over classical monte carlo methods. \\
Suppose a unitary operator $A$ is acting on a register of $(n+1)$ qubits
\begin{align}\label{eq:actionOfA}
  A\ket{0}_{n+1} &= \sqrt{1-a}\ket{\psi_0}_{n}\ket{0}+\sqrt{a}\ket{\psi_1}_{n}\ket{1}, \label{eq:AE_A}
\end{align}
for normalised states $\ket{\psi_0}_{n}\ket{0}$, $\ket{\psi_1}_{n}\ket{1}$ and unknown $a \in [0,1]$.
QAE allows the efficient estimation of $a$, i.e. the probability of measuring $\ket{1}$ in the last qubit
Simply measuring $\ket{1}$ t times does not give any advantage since the variance of t is defined by a bernoulli distibution
\begin{equation}\label{eq:t}
  t = O(\frac{a(1-a)}{\epsilon^2}),
\end{equation}
with given accuracy $\epsilon$.\\
To gain a quantum speed-up more efficient quantum algorithm are used than simply measuring t times. 
From $\ref{eq:actionOfA}$ it can be seen that
\begin{equation}\label{eq:aIsSin}
  a = sin^2(\theta_a),
\end{equation}
what comes frome the fact that exchanging $a \text{ and } 1-a$ by sin and cos would result in same quantum behavior.\\
The first efficient quantum algorthim is Grovers algorithmn, where
\begin{align}
  Q &= AS_0AS_{\psi_0} \nonumber \\
  S_0 &= 1-2\ket{0}\bra{0} \nonumber \\
  S_{\psi_0} &= 1-2\ket{\psi_0}\ket{0}\bra{\psi_0}\bra{0}. \nonumber \\
\end{align}
$Q$ applies a rotation of angle $2\theta_a$ in the complex two-dimensional Hilbert space spannend by $\ket{\psi_0}\ket{0}$ and
$\ket{\psi_1}\ket{0}$. The eigenvalues of $Q$ are (Euler formula) $\exp{ (\pm \theta_a)}$.\\
To obtain an approximation for $\theta_a$ QAE applies Quantum Phase Estimation(QPE) to approximate the eigenvalues of $Q$.
QPE uses $m$ additional sampling qubits to represent the results and $M=2^m$ applications of $Q$.\\
For that the $m$ qubits are initialized to a equal superposition by Hadamard gates and are then used to control the different powers of $Q$
applied to the QAE register. After application of an inverse Quantum Fourier Transformation (QFT) the state of QAE register is measured, resulting in
$y \in {0,..., M-1}$ which is classically mapped to the estimator of $a$
\begin{equation}
  \tilde{a} = \sin^2(y \pi / M) \in [0,1] \label{eq:estimate_a}.
\end{equation}
Focusing on the efficiency of the algorithm described above it can be observed from \ref{eq:classic_M} and \ref{eq:AE_M} that $\tilde{a}$
satisfies:
\begin{align}
    |\tilde{\a} - \a| &\leq (\frac{\sqrt{\pi}}{M} + \frac{\pi}{M^2}) = O(M^-1), \label{eq:AE_M}
\end{align}
with probability of at least $(\frac{8}{\pi})$. Result $\ref{eq:AE_M}$ represents a quadratic speed-up in comparision to the classical efficiency $\ref{eq:t}$.
\subsubsection{European Option Pricing}\label{sec:eurOpPricing}
For option contracts the involved random variables represent the possible values $S_T$ the underlying asset can take and the probabilities $p_i$ that those values will be realized.
For the unitary $A$ that means: Given an n+1-qubit register $N$ (QAE register), asset prices at maturity $ \{ S_i \} $ for $ i \in \{ 0,..,2^n-1 \} $, the corresponding probabilites $ \{ p_i \}$ and the option payoff
$f(S_i)$ the operator $A$ becomes
\begin{equation}\label{eq:AWitha}
  A = \sum_{i=0}^{2n+1} \bigl ( \sqrt{1-f(S_i)}\sqrt{p_i}\ket{S_i}\ket{0} + \sqrt{f(S_i)}\sqrt{p_i}\ket{S_i}\ket{1} \bigr ).
\end{equation}
Comparing $\ref{eq:AWitha} \text{ and } \ref{eq:actionOfA}$ gives for options
\begin{equation}\label{eq:aForOption}
  a = \sum_{i=0}^{2n+1} f(S_i)p_i = E[f(S_T)].
\end{equation}
For option pricing using QAE that means that in order to be able to apply QAE the unitary operator $A$ has to be created using quantum circuits, i.e. a efficient method to encode
the probabilities $p_i$ for a certain stock price at maturity $S_i$ and the corresponding payoff $f(S_i)$ in the register $N$.
%--> start here

% discuss in more detail where the accuracy 8/pi comes from QPE
% show that ket{S_i} is binary representation of asset price. Write down how quantum register looks like after application of QPE
% -> i.e. U is Q, \ket{S_i} leads to 2^i times application of \theta_n implemented by Q 
% check qpe wiki article. 
On a quantum computer the task to perform a monte carlo is in general threefold(\cite{Stamatopoulos_2019}).
First given an n-qubit register $M$, asset prices $ \{ S_i \} $ for $ i \in \{ 0,..,2^n-1 \} $ the corresponding probabilites $ \{ p_i \}$ 
have to be encoded in $M$. In BSM-model the analytical formulas to price options assume that the underlying stock price at maturity follows a log-normal distribution
with constant volatility \ref{eq:lognormal}. Second the payoff of european call options has additionally to be integrated 
The distribution loading algorithm creates the following n-qubit state:
\begin{equation}\label{eq:probState}
\ket{\Phi}_n = \sum_{i=0}^{2^n-1} \sqrt{p_i} \ket{S_i}_n.
\end{equation}
The algorithm for creating $ref{eq:probState}$ reads:
\begin{itemize}
  \item On an interval, which is described by the minimal and maximal asset price an equidistant discretization is established
   based in the number of quantum states $M=2^n-1$.
  \item Equidistant x-values are used to compute log-normal probability of the asset prices.
  \item The probabilites are normalized by the sum of all probabilites
  \item The square root is applied and resulting numbers initialized in a quantum state.
\end{itemize} 
The algorithm for the distribution loading can then be implemented like:
\begin{lstlisting}
  def logNormalDistribution(num_qubits, mu, sigma, bounds: tuple, name):
    qc = QuantumCircuit(num_qubits, name=name)
    x = np.linspace(bounds[0], bounds[1], num=2**num_qubits)
    probabilities = []
    for x_i in x:
        # map probabilities from normal to log-normal reference:
        # https://stats.stackexchange.com/questions/214997/multivariate-log-normal-probabiltiy-density-function-pdf
        if np.min(x_i) > 0:
            det = 1 / np.prod(x_i)
            probability = multivariate_normal.pdf(np.log(x_i), mu, sigma) * det
        else:
            probability = 0
        probabilities += [probability]
        normalized_probabilities = probabilities / np.sum(probabilities) 
        
    initialize = Initialize(np.sqrt(normalized_probabilities))
    circuit = initialize.gates_to_uncompute().inverse()
    qc.compose(circuit, inplace=True)
    return qc, x, probabilities
\end{lstlisting}


%% old stuff
\begin{enumerate}
	\item The payoff function $F(\textbf{X})$ has to be build with qubits inside the quantum computer. In section \ref{sec:MC_Payoff} the payoff function is constructed.
	\item The quantum computer should calculate at the end the expected value of the payoff $\mathbb{E}_P[F(\textbf{X})]$, this will also be explained in section \ref{sec:MC_Payoff}.
\end{enumerate}
But before we can describe how to construct the gates to build the payoff function, we need to explain how amplitude estimation is working in an quantum computer. We are doing this in section \ref{sec:MC_AE}

\subsubsection{Amplitude Estimation}\label{sec:MC_AE}
For the Amplitude Estimation (AE) we need an unitary operator $A$ which behaves on an register of $(n+1)$ qubits like this
\begin{align}
    A\ket{0}_{n+1} &= \sqrt{1-a}\ket{\psi_0}_{n}\ket{0}+\sqrt{a}\ket{\psi_1}_{n}\ket{1}. \label{eq:AE_A}
\end{align}

In the equation \ref{eq:AE_A} $\ket{\psi_0}_{n}$ and $\ket{\psi_1}_{n}$ are some normalized states and $a$ is a unknown variable $\in [0,1]$.
With Amplitude Estimation we can estimate the value of $a$ therefor we have to construct our problem so that we have this at the end $a=\mathbb{E}_P[f(\textbf{X})]$.
To make a use of $\sin$ and $\cos$ to work with RY-Gates we can say that $a=\sin^2(\theta_a)$ is, so that equation \ref{eq:AE_A} turns into this
\begin{align}
    A\ket{0}_{n+1} &= \cos(\theta_a)\ket{\psi_0}_{n}\ket{0}+\sin(\theta_a)\ket{\psi_1}_{n}\ket{1}. \label{eq:AE_A_sin} \\
    \theta_p &= 2 \theta_a \nonumber \\
    A &= R_Y(\theta_p)
\end{align}

With this changes we transformed the amplitude estimation in to a phase estimation.\\
The next step is to determine the Grover operator $\mathcal{Q}=AS_0A^\dagger S_{\psi_1}$.\\
$S_0$ is a reflection about the $\ket{0}$ state and $S_{\psi_1}$ is a reflection about the $|\psi_1>$ state. So we can write $S$ and $\mathcal{Q}$ like this:
\begin{align}
    S_0 &= 1-2\ket{0}\bra{0} \nonumber \\
    S_{\psi_1} &= 1-2\ket{\psi_1}\ket{0}\bra{\psi_1}\bra{0} \nonumber \\
    \mathcal{Q} &= R_Y(2\theta_p) \\ 
    \mathcal{Q}_{2^j} &= R_Y(2^j\cdot 2\theta_p)
\end{align}
\begin{figure}[H]
  \begin{center}
\begin{quantikz}
\lstick{(0) \ket{0}} & \gate{H} & \ctrl{5} & \ldots \qw & \qw & \ldots \qw & \qw & \gate[5, nwires={2,4}]{QFT^{\dagger}} &  \meter{}\\
 & \vdots & & \ddots & & \ddots & & \\
\lstick{(j) \ket{0}} & \gate{H} & \qw & \ldots \qw & \ctrl{3} & \ldots \qw & \qw & & \meter{}\\
 & \vdots & & \ddots & & \ddots & &\\
\lstick{(n-1) \ket{0}} & \gate{H} & \qw & \ldots \qw & \qw & \ldots \qw & \ctrl{1} & &  \meter{}\\
\lstick{(n) \ket{0}} & \gate[wires=2]{A} & \gate[wires=2]{\mathcal{Q}_{2^0}} & \ldots \qw & \gate[wires=2]{\mathcal{Q}_{2^j}} & \ldots \qw & \gate[wires=2]{\mathcal{Q}_{2^{n-1}}} & \qw\\
\lstick{(n+m-1) \ket{0}} &  & & \ldots \qw &  & \ldots \qw & & \qw
\end{quantikz}
\end{center}
\caption{ Design of the Amplitude Estimation recreated after \cite{Stamatopoulos_2019}}
\label{fig:qae}
\end{figure}
The error $\epsilon$ of this method defined as followed
\begin{align}
    |\hat{\Pi} - \Pi| &\leq C\cdot(\frac{\sqrt{\mathbb{E}}}{M} + \frac{1}{M^2}) \nonumber \\
    M &= \mathcal{O}(\frac{1}{\epsilon \sqrt{\mathbb{E}}}) \label{eq:AE_M}
\end{align}
As we can see in \ref{eq:classic_M} and \ref{eq:AE_M} quantum computer improved the number error with the same number of samples
\subsubsection{Construct the payoff function}\label{sec:MC_Payoff}
A lot of payoff function can be constructed by piece-wise linear functions, in this section we will go over how to construct the piece-wise linear function in to quantum computer.

First of all we need to transform the payoff function $F(\textbf{X})$ in to new functions $f_b(i)=m_b\cdot i + o_b$, with $m_b$ the slope of the function and $o_b$ the offset of the function. For every break point $b$ of the payoff function we need to create a new function $f_b$. The new function gets the following as input $i\in\{0,\ldots, 2^n-1\}$, which represents all states the qubits can have. For example we have three qubits ($i\in\{0,1,2,3,4,5,6,7\}$) so $\ket{011}$ mapes to $i=3$. The output of the function can also only be $f(i)\in[0,1]$ this was shown in section \ref{sec:MC_AE}. Now that we build the function we can insert the function in this equation \ref{eq:AE_A_sin} and get this new equation
\begin{align}
    \ket{i}_n\ket{0} &= \ket{i}_n(\cos[f(i)]\ket{0}+\sin[f(i)]\ket{1}) \label{eq:PF_f}
\end{align}

So this function can be rebuild in a quantum computer with controlled $Y$-Rotations $CR_y$ and normal $Y$-Rotations $R_y$, the normal $Y$-Rotation is only used to initially rotate the qubit, which corresponds to the first offset. To do this we need an extra qubit on which we perform the rotations based on $x$ encoded in register $\ket{i}_n$ which is already holding the probability distribution. Similar to the Amplitude Estimation the rotations add a factor $2^{j}$, where the ${j}$'s are qubits from $\ket{i}_n$-register. (shown in figure \ref{fig:PF_y}) Consequently the more $\ket{j}$ are set to $\ket{1}$, the higher the value of $x$ is. If we add more qubits to $\ket{i}_n$-register, i.e. more grid-points, a higher accuracy can be reached.

\begin{figure}[H]
  \begin{center}
\begin{quantikz}
\lstick{\ket{q_0}} & \qw & \ctrl{3} & \qw & \qw & \qw\\
\lstick{\ket{q_1}} & \qw & \qw & \ctrl{2} & \qw & \qw\\
\lstick{\ket{q_2}} & \qw & \qw & \qw & \ctrl{1} & \qw\\
\lstick{\ket{q_3}} & \gate[1]{R_y(f_0)} & \gate[1]{CR_y(f_1)} & \gate[1]{2CR_y(f_1)} & \gate[1]{4CR_y(f_1)} & \qw
\end{quantikz}
\end{center}
\caption{ Quantum circuit for a linear function. Base image copied from \cite{Stamatopoulos_2019}}
\label{fig:PF_y}
\end{figure}

Until now we only showed how to implement a linear function but every piece-wise linear function applies only on specific states. Now we have to build a greater or equal operation in a quantum computer, since we are dealing with a $max$ function in eq. $\ref{eq:E_example_european}$. For this we need also $n$ qubits, one of the qubits has the result at the end. So for this operation we have $n$ data qubits $\ket{q}$ and $n$ qubits for the greater or equal operation $\ket{a}$. To build the operation we can follow this steps (example of a circuit is in figure \ref{fig:PF_max}). 
\begin{enumerate}
	\item At first we convert the breakpoint $b\in[0,2^n-1]$ in a bit representation $t$. For this we use a ceil operation on b and convert it then in a bit representation $t$. Every bit represent one qubit. If the breakpoint lies between two grid points $i$, the ceil operation ensures that the respective larger grid point is used as breakpoint for controlled application of max-operation.
	\item Now we can iterate over all the qubits. (we use here $j$ as iterate parameter)
	\begin{itemize}
	    \item if it is the first qubit $j=0$ and $t[j]=1$, we have to perform a $CX$ operation on $\ket{q_j}$ and $\ket{a_j}$.
	    \item if $t[j]=1$ an $OR$-Operation has to be done on $\ket{q_j}$ and $\ket{a_{j-1}}$ the result of the $OR$-Operation will be saved in $\ket{a_j}$
	    \item if $t[j]=0$ an $CCX$-Operation has to be done on $\ket{q_j}$, $\ket{a_{j-1}}$ and $\ket{a_j}$
    \end{itemize}
    \item Now we have in $a_{n-1}$ the result saved $\ket{0}$ if $i<b$ and $\ket{1}$ if $i\geq b$.
    \item What we have to do now is to reverse the process except that now $j\in{n-1, \ldots, 0}$ is. So we do not consider the last qubit because it saves the result. To reverse an $CX$, $CCX$ and $OR$-Operation we only have to apply the same operator again.
\end{enumerate}
\begin{figure}[H]
  \begin{center}
\begin{quantikz}
\lstick{\ket{a}} & \gate{X} & \ctrl{2} & \gate{X} &  \midstick[3,brackets=none]{$\equiv$}\qw & \ctrl{2} & \qw\\
\lstick{\ket{b}} & \gate{X} & \ctrl{1} & \gate{X} & \qw & \ctrl{1} & \qw\\
\lstick{\ket{c}} & \gate{X} &  \targ{} & \qw & \qw & \gate{OR} & \qw
\end{quantikz}
\end{center}
\caption{ Example of an $OR$-Operation on qubit $\ket{a}$ and $\ket{b}$. The result is then saved in $\ket{c}$. Base image copied from \cite{Stamatopoulos_2019}}
\label{fig:PF_OR}
\end{figure}

\begin{figure}[H]
  \begin{center}
\begin{quantikz}
 & & & & &  & & & & & & &  \gategroup[9,steps=7,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt},background]{{Inverse for n-2 to 0}}    & & & &  &  &    \\
\lstick{\ket{q_0}} & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}]{{t[0]=1}} & \qw & \qw & \qw & \qw & \qw  & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}]{{t[0]=1}} & \qw  \\
\lstick{\ket{q_1}} & \qw & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}, label style={label position=below,anchor=north,yshift=-0.2cm}]{{t[1]=0}} & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}, label style={label position=below,anchor=north,yshift=-0.2cm}]{{t[1]=1}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}, label style={label position=below,anchor=north,yshift=-0.2cm}]{{t[1]=0}} & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}, label style={label position=below,anchor=north,yshift=-0.2cm}]{{t[1]=1}} & \qw & \qw & \qw \\
\lstick{\vdots} & & & &  & & \vdots & & & & & \vdots & & & & &  &  &    \\
\lstick{\ket{q_{n-1}}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{4}\gategroup[6,steps=1,style={dashed,rounded corners, inner xsep=2pt}]{{t[n-1]=0}} & \qw & \ctrl{4}\gategroup[6,steps=1,style={dashed,rounded corners, inner xsep=2pt}]{{t[n-1]=1}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw \\
\lstick{\ket{a_0}} & \targ{} & \qw & \ctrl{1} & \qw & \ctrl{1} & \qw & \qw & \qw & \qw & \qw  & \qw & \qw & \qw & \qw & \qw & \qw & \targ{} & \qw   \\
\lstick{\ket{a_1}} & \qw & \qw & \targ{} & \qw & \gate{OR} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \targ{} & \qw & \gate[style={fill=blue!20}]{OR} & \qw & \qw & \qw \\
\lstick{\vdots} & & & & & & \vdots & & & & & \vdots & & & &  & &  & \\
\lstick{\ket{a_{n-2}}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{1} & \qw & \ctrl{1} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw \\
\lstick{\ket{a_{n-1}}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \targ{} & \qw & \gate{OR} & \qw & \qw & \qw & \qw & \qw  & \qw & \qw & \qw 
\end{quantikz}
\end{center}
\caption{ Basic structure of an circuit for the bigger then operation. Base image copied from \cite{Stamatopoulos_2019}}
\label{fig:PF_max}
\end{figure}

So now we have a qubit $a_{n-1}$ (control qubit) which holds the information if $i\geq b$. This control qubit is then used to control if the rotations of breakpoint $b$ are executed or not. After applying the $Y$ Rotations for a breakpoint $b$ the inverse of the greater or equal operation has to applied to the circuit, so that the states are all $\ket{0}$ for the next breakpoint. 
Note that a smaller-than operations can be realized by adding a bit-flip X-gate to qubit $a_{n-1}$.

Now that we have shown how to construct a piece-wise linear function in a quantum computer we change $\theta_P$ again to better obtain our desired result $\mathbb{E}$.
\begin{align}
    \theta_P &= c\tilde{f}_b(i)+\frac{\pi}{4}\label{eq:theata_P} \\
    \tilde{f}_b(i) &= 2 \frac{f_b(i)-f_{\text{min}_b}}{f_{\text{max}_b}-f_{\text{min}_b}}\label{eq:f_bi}
\end{align}

Equation \ref{eq:theata_P} is chosen to center $ \sin^2(\theta_P) $ around $\tilde{f}_b(i) = 0$ and \ref{eq:f_bi} so that $\tilde{f}_b(i) \in [-1,1] $

At the end of the Amplitude Estimation we only have to calculate the result.
To obtain an approximation for $\theta_p$, AE applies Quantum Phase Estimation to approximate certain eigenvalues of $\mathcal{Q}$, which are classically mapped to an estimator for $a$. The Quantum Phase Estimation uses $m$ additional sampling qubits to represent result and $M = 2^m$ applications of $\mathcal{Q}$, i.e., $M$ quantum samples. 
The $m$ qubits, initialized to an equal superposition state by Hadamard gates, are used to control different powers of $\mathcal{Q}$. After applying an inverse Quantum Fourier Transform, their state is measured resulting in an integer $y \in \{0, ..., M - 1\}$, which is classically mapped to the estimator for $a$, i.e.

\begin{equation}
    \tilde{a} = \sin^2(y \pi / M) \in [0,1] \label{eq:estimate_a}.
\end{equation}

\biblio
\end{document}