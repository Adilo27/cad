\documentclass[../../main.tex]{subfiles}

\begin{document}


\subsection{Quantum Monte Carlo}\label{sec: qmc}
Quantum Amplitude Estimation provides a quadratic speed-up over classical monte carlo methods. \\
Suppose a unitary operator $A$ is acting on a register of $(n+1)$ qubits
\begin{equation}\label{eq:action_of_A}
  A\ket{0}_{n+1} = \sqrt{1-a}\ket{\psi_0}_{n}\ket{0}+\sqrt{a}\ket{\psi_1}_{n}\ket{1},
\end{equation}
for normalised states $\ket{\psi_0}_{n}\ket{0}$, $\ket{\psi_1}_{n}\ket{1}$ and unknown $a \in [0,1]$.
QAE allows the efficient estimation of $a$, i.e. the probability of measuring $\ket{1}$ in the last qubit.\\
Simply measuring $\ket{1}$ t times does not give any advantage since the variance of t is defined by a bernoulli distibution
\begin{equation}\label{eq:t}
  t = O(\frac{a(1-a)}{\epsilon^2}),
\end{equation}
with given accuracy $\epsilon$.\\
To gain a quantum speed-up more efficient quantum algorithms are used than simply measuring t times. 
From \ref{eq:action_of_A} it can be seen that
\begin{equation}\label{eq:aIsSin}
  a = sin^2(\theta_a),
\end{equation}
what comes from the fact that exchanging $a \text{ and } 1-a$ by sin and cos would result in same quantum behavior:\\
\begin{equation}\label{eq:action_of_A_sin}
  A\ket{0}_{n+1} = cos(1-a)\ket{\psi_0}_{n}\ket{0}+sin(1-a)\ket{\psi_1}_{n}\ket{1}
\end{equation}

The first efficient quantum algorthim used is amplitude estimation which is the general case of Grovers algorithm, where
\begin{align}
  Q &= AS_0AS_{\psi_0} \nonumber \\
  S_0 &= 1-2\ket{0}\bra{0} \nonumber \\
  S_{\psi_0} &= 1-2\ket{\psi_0}\ket{0}\bra{\psi_0}\bra{0}. \nonumber \\
\end{align}
$Q$ applies a rotation of angle $2\theta_a$ in the complex two-dimensional Hilbert space spannend by $\ket{\psi_0}\ket{0}$ and
$\ket{\psi_1}\ket{0}$. The eigenvalues of $Q$ are (Euler formula) $\exp{ (\pm i \theta_a)}$.\\
The Grover algorithm therefore is used to encode the angle $\theta_a$ as the argument of an exponential function in the quantum register but does not yield an approximation of that angle.
To obtain an approximation for $\theta_a$ QAE applies Quantum Phase Estimation(QPE) to approximate the eigenvalues of $Q$.
QPE uses $m$ additional sampling qubits to represent the results and $M=2^m$ applications of $Q$.\\
For that the $m$ qubits are initialized to a equal superposition by Hadamard gates and are then used to control the different powers of $Q$
applied to the QAE register. After application of an inverse Quantum Fourier Transformation (QFT) the state of QAE register is measured, resulting in
$y \in {0,..., M-1}$ which is classically mapped to the estimator of $a$
\begin{equation}
  \tilde{a} = \sin^2(y \pi / M) \in [0,1] \label{eq:estimate_a}.
\end{equation}
Focusing on the efficiency of the algorithm described above it can be observed from \ref{eq:classic_M} and \ref{eq:AE_M} that $\tilde{a}$
satisfies:
\begin{align}
    | \tilde{a} - a | &\leq (\frac{\sqrt{\pi}}{M} + \frac{\pi}{M^2}) = O(M^{-1}), \label{eq:AE_M}
\end{align}
with probability of at least $(\frac{8}{\pi^2})$. Result $\ref{eq:AE_M}$ represents a quadratic speed-up in comparision to the classical efficiency $\ref{eq:t}$.
\begin{figure}[H]
  \begin{center}
\begin{quantikz}
\lstick{(0) \ket{0}} & \gate{H} & \ctrl{5} & \ldots \qw & \qw & \ldots \qw & \qw & \gate[5, nwires={2,4}]{QFT^{\dagger}} &  \meter{}\\
 & \vdots & & \ddots & & \ddots & & \\
\lstick{(j) \ket{0}} & \gate{H} & \qw & \ldots \qw & \ctrl{3} & \ldots \qw & \qw & & \meter{}\\
 & \vdots & & \ddots & & \ddots & &\\
\lstick{(n-1) \ket{0}} & \gate{H} & \qw & \ldots \qw & \qw & \ldots \qw & \ctrl{1} & &  \meter{}\\
\lstick{(n) \ket{0}} & \gate[wires=2]{A} & \gate[wires=2]{\mathcal{Q}_{2^0}} & \ldots \qw & \gate[wires=2]{\mathcal{Q}_{2^j}} & \ldots \qw & \gate[wires=2]{\mathcal{Q}_{2^{n-1}}} & \qw\\
\lstick{(n+m-1) \ket{0}} &  & & \ldots \qw &  & \ldots \qw & & \qw
\end{quantikz}
\end{center}
\caption{ Design of the Amplitude Estimation. Operator A combines distribution loading and payoff construction as defined in \ref{eq:action_of_A}.
$\mathcal{Q}$ to rotate given state around $2*\theta_a$ in Hilbert-space spanned by $\ket{\phi_0}\ket{0}$ and $\ket{\phi_1}\ket{1}$. Inverse QFT is then applied
to obtain the estimate $\tilde{a}$ of a.
}
\label{fig:qae}
\end{figure}

\subsubsection{Quantum Phase Estimation}\label{sec:QPE}
In short Quantum Phase Estimation (QPE) has the purpose to estimate $\theta$ in $U\ket{\phi} = e^{2 \pi i \theta }$, given a unitary operator $U$.
$\ket{\phi}$ is an eigenvector and $e^{2 \pi i \theta }$ the corresponding eigenvalue.\\
Starting with two qubit registers $\ket{\phi}$ and $\ket{0^n}$, with $\ket{0^n}$ the counting register
which will store the value $2^n \theta$. After applying Hadamard gates to the counting register and n controlled Operations $CU^{2j}$ the initial state has evolved to
\begin{equation}
  \ket{\phi} = \frac{1}{2^{\frac{n}{2}}} \sum_{k=0}^{2^n-1} e^{2 \pi i \theta k} \ket{k} \otimes \ket{\phi}.
\end{equation}
Note that $0 \le j \le n-1$ and $U$ is controlled by the register $\ket{\phi}$. Furthermore $k$ denotes the integer representation of n-bit binary numbers.\\
After applying  an inverse quantum Fourier transformation, to recover the state $\ket{2^n \theta}$, we find
\begin{equation}
  \frac{1}{\frac{n}{2}} \sum_{x=0}^{2^n-1} \sum_{k=0}^{2^n-1} e^{\frac{2 \pi i k}{2^n}(x - 2^n \theta)} \ket{x} \otimes \ket{\phi}.
\end{equation}
This expression peaks near $x=2^n \theta$. Measuring the computational basis in counting register gives the Phase
\begin{equation}
  \ket{\phi} = \ket{2^n \theta} \otimes \ket{\phi}.
\end{equation}
For the case $2^n \theta$ is an integer the right phase is measured with high probability close to 1. Otherwise it can be shown that one measures the right phase
with probability better than $\frac{4}{\pi^2} \approx 40 \% $.\\
!!!Citation qiskit here!!!

\begin{lstlisting}[caption={Example of phaseestimation algorithm used for results of this paper.},captionpos=b]
  def phase_estimation(num_evaluation_qubits: int,
        unitary: QuantumCircuit,
        iqft: Optional[QuantumCircuit] = None,
        name: str = "QPE"):
    """
        Args:
            num_evaluation_qubits: The number of evaluation qubits.
            unitary: The unitary operation :math:`U` which will be repeated and controlled.
            iqft: A inverse Quantum Fourier Transform, per default the inverse of
                :class:`~qiskit.circuit.library.QFT` is used. Note that the QFT should not include
                the usual swaps!
            name: The name of the circuit.
    """
    qr_eval = QuantumRegister(num_evaluation_qubits, "eval")
    qr_state = QuantumRegister(unitary.num_qubits, "q")
    circuit = QuantumCircuit(qr_eval, qr_state, name=name)
    iqft = QFT(num_evaluation_qubits, inverse=True, do_swaps=False).reverse_bits()
    circuit.h(qr_eval)  # hadamards on evaluation qubits

    for j in range(num_evaluation_qubits):  # controlled powers
        circuit.append(unitary.power(2**j).control(), [j] + qr_state[:])
    circuit.append(iqft.to_gate(), qr_eval[:])  # final QFT
    return circuit
\end{lstlisting}

\subsubsection{Amplitude Amplification}\label{sec:amplitudeAmplification}


As already mentioned amplitude amplification is the general case of grovers algorithmn. It amplifies the probability to measure a "good" part of a algorithm.\\
This algorithm is in our case the circuit A. Suppose it initilizes n qubits, such that
\begin{equation}\label{eq:amplitudeAmplA}
  \ket{\phi} = A\ket{0}_{n} = \sqrt{1-a}\ket{\phi_0}_{n} +\sqrt{a}\ket{\phi_1}_{n},
\end{equation}
where $\ket{\phi_0}, \ket{\phi_1}$ are both normalized n-qubit states and orthorgonal to each other.
For example could it be that the last qubit of $\ket{\phi_0} \text{ } \ket{0}$ and $\ket{\phi_1} \text{ } \ket{1}$ is.
Let us denote $\ket{\phi_1}$ as the good-state, what means that the probability $\sqrt{a}$ should be increased.\\
Furthermore $\ket{\phi_0}$ and $\ket{\phi_1}$ can be viewed as the horizontal and vertical axes of a two-dimensional Hilbert space. The angle between $\ket{U}$ and the horizontal axis is thus
$\theta_a = \arcsin(\sqrt{a})$. Obviously we would like to rotate the initial state $\ket{\phi}$ towards the good-state, i.e. to the e.g. the vertical axis.\\
The rotation is implemented as for Grover by defining a product of two reflections: a reflection trough the bad state and a reflection through $\ket{U}$.
The first reflection is realized by a circuit $S_{\phi_0}$ which can distinguish the good from the bad state by putting a minus in front of $\ket{\phi_1}$ and leaving $\ket{\phi_0}$ alone.
In case the last qubits are $\ket{1}, \ket{0}$ for $\ket{\phi_1}, \ket{\phi_0}$ respectively, then the reflection would be
\begin{equation}\label{eq:PhiReflection}
  S_{\psi_0} = 1-2\ket{\psi_0}\ket{0}\bra{\psi_0}\bra{0},
\end{equation}
and can in turn be realized by applying a Z-gate to the last qubit.\\
The second reflection can be implemented as $AR_{0}A^{\dagger} = AR_0A$ with $R_0$
\begin{equation}\label{eq:ZeroReflection}
  R_0 = 2\ket{0^n}\bra{0^n} - \mathbb{1}.
\end{equation}
 $AR_0A$ puts a minus sign in front of states orthorgonal to $\ket{U}$. The product of both reflection is then (thanks to Grover) a rotation of angle
 $2\theta$ in the two-dimensional picture introduced above. \\
 The following amplitude amplification procedure increases the amplitude of the good state close to 1:
\begin{enumerate}
  \item{Setup the starting state $\ket{U} = A\ket{0^n}$}.
  \item{Repeat the following $\mathcal{O}(1 \sqrt{a})$}.
  \begin{itemize}
    \item Reflect through bad state $\ket{\phi_0}$ ($R_G$).
    \item Reflect through $\ket{U}$ ($AR_0A$).
  \end{itemize}
\end{enumerate}
After k iterations the state is 
\begin{equation}\label{eq:Qktimes}
\mathcal{Q}^k \ket{U} = \sin \biggl[ (2k+1)\theta_a \biggr] \ket{\phi_1} + \cos \biggl[ (2k+1)\theta_a \biggr] \ket{\phi_0}.
\end{equation}
We would like to end up with an angle $(2k+1)\theta_a \approx \pi/2$ to be close to $\sin(pi/2) \approx 1$.\\
The above explanation describes how amplitude amplification is applied to the initial state $\ket{\phi}$ in order to amplify the good state $\ket{phi_1}$.
But how is this actually connected to Quantum Phase Estimation which then gives a estimation $\tilde{a}$?\\
Given again the statevector which is defined to be living in a two-dimensional subspace $H_{\phi}$: $\ket{\phi} \in H_{\phi}$ spannend by two orthogonal and normalized
projectors $\ket{\phi_1}, \ket{\phi_0}$ onto $H_1$ and $H_0$.\\
The action of $\mathcal{Q} := AR_0AR_g$ is given by
\begin{align}\label{eq:actionOfQ}
  \mathcal{Q} \ket{\phi_0} &= (2 \cos^2(\theta_a) - 1 )\ket{\phi_0} + 2 \sin(\theta_a)cos(\theta) \ket{\phi_1}\\
  \mathcal{Q} \ket{\phi_1} &= -2 \sin(\theta_a) \cos(\theta_a) \ket{\phi_0} 
\end{align}
Thus $mathcal{Q}$ corresponds to rotation by $2\theta_a$ in $H_\phi$
\begin{equation}\label{eq:rotationMatrix}
  \mathcal{Q} = 
\begin{pmatrix}
      cos(2\theta_a) & -sin(2 \theta_a) \\
      sin(2\theta_a) & cos(2 \theta_a) 
\end{pmatrix},
\end{equation}
which has the well has eigenvalues $\lambda_{\pm} = e^{\pm i \theta_a}$.\\
Since $\mathcal{Q}$ is unitary and therefore there is an orthonormal basis of the subspace $H_{\phi}$ formed
by the two eigenvectors of $\mathcal{Q}$.
\begin{equation}\label{eq:eigenvectors}
  \begin{pmatrix}
    1\\
    i
  \end{pmatrix}
  ,
  \begin{pmatrix}
    1\\
    -i
  \end{pmatrix}.
\end{equation}
For $H_{\phi}$ the basis-states can be defined as
\begin{equation}\label{eq:HBasisStates}
  \ket{\phi_{\pm}} = \frac{1}{\sqrt{2}} (\ket{\phi_1} \pm i \ket{\phi_0}).
\end{equation} 
Express $\ket{\phi} = A \ket{0^n}$ in eigenvector basis 
\begin{equation}
  \ket{\phi} = \frac{1}{\sqrt{2}} ( \ket{\phi_+} + \ket{\phi_-}).
\end{equation}
After j applications of $\mathcal{Q}$ it is obvious that the state is
\begin{equation}\label{eq:PhiAfterJQ}
  \ket{\phi} = \frac{1}{\sqrt{2}} ( e^{2j \cdot i \theta_a}\ket{\phi_+} + e^{-2j \cdot i \theta_a}\ket{\phi_-})
\end{equation}
The last equation can then be utilized as a controlled unitary in QPE algorithmn. QPE will be peaked where $y/2^n = \pm \tilde{\theta_a}$,
with $\tilde{\theta}_a$ an n-bit approximation of $\theta_a$.
\begin{lstlisting}[caption={Implementation of reflections for amplitude amplification as used trought the rest of the paper},captionpos=b]
  def grover_operator_oracle(num_qubits:int, num_ancillas:int, objective_qubits: List[int]) -> QuantumCircuit:
    # build the reflection about the bad state (zero Reflection): a MCZ with open controls (thus X gates
    # around the controls) and X gates around the target to change from a phaseflip on
    # |1> to a phaseflip on |0>
        num_state_qubits = num_qubits - num_ancillas
        oracle = QuantumCircuit(num_state_qubits, name="S_f")
        oracle.h(objective_qubits[-1])
        if len(objective_qubits) == 1:
            oracle.x(objective_qubits[0])
        else:
            oracle.mcx(objective_qubits[:-1], objective_qubits[-1])
        oracle.h(objective_qubits[-1])
        return oracle
  def zero_reflection(num_qubits: int, num_ancillas: int, reflection_qubits: List[int], mcx_mode: str) -> QuantumCircuit:
    reflection = QuantumCircuit(num_qubits - num_ancillas, name="S_0")
    if num_ancillas > 0:
        qr_ancilla = AncillaRegister(num_ancillas, "ancilla")
        reflection.add_register(qr_ancilla)
    else:
        qr_ancilla = []
    reflection.x(reflection_qubits)
    if len(reflection_qubits) == 1:
        reflection.z(0)  
        # MCX does not allow 0 control qubits, therefore this is separate
    else:
        reflection.h(reflection_qubits[-1])
        reflection.mcx(reflection_qubits[:-1], reflection_qubits[-1], qr_ancilla[:], mode=mcx_mode)
        reflection.h(reflection_qubits[-1])
    reflection.x(reflection_qubits)
    return reflection
\end{lstlisting}

\subsubsection{European Option Pricing}\label{sec:eurOpPricing}

For option contracts the involved random variables represent the possible values $ \{ S_i \} $ for $ i \in \{ 0,..,2^n-1 \} $ the underlying asset can take and the probabilities $p_i$ that those values will be realized.
For the unitary $A$ that means: Given an n+1-qubit register $N$ (QAE register), asset prices at maturity $S_T $, the corresponding probabilites $ \{ p_i \}$ and the option payoff
$f(S_i)$ the operator $A$ becomes
\begin{equation}\label{eq:A_with_a}
  A = \sum_{i=0}^{2n+1} \bigl ( \sqrt{1-f(S_i)}\sqrt{p_i}\ket{S_i}\ket{0} + \sqrt{f(S_i)}\sqrt{p_i}\ket{S_i}\ket{1} \bigr ).
\end{equation}
Comparing \ref{eq:A_with_a} and \ref{eq:action_of_A} gives for options
\begin{equation}\label{eq:aForOption}
  a = \sum_{i=0}^{2n+1} f(S_i)p_i = E[f(S_T)].
\end{equation}
\ref{eq:A_with_a} is the expectation value of the payoff given the stockprice at maturity and therefore the quantity which we want to approximated with Monte Carlo Simulations.
For option pricing using QAE that means that in order to be able to apply QAE the unitary operator $A$ has to be created using quantum circuits, i.e. a efficient method to encode
the probabilities $p_i$ for a certain stock price at maturity $S_i$ and the corresponding payoff $f(S_i)$ in the register $N$.

\subsubsection{Loading the distribution}\label{sec:loadingDist}
The algorithm for loading the probability distribution \ref{eq:lognormal} reads:
\begin{itemize}
  \item On an interval, which is described by the minimal and maximal asset price an equidistant discretization is established
   based on the number of quantum states $M=2^n-1$.
  \item Equidistant x-values are used to compute log-normal probability of the asset prices \ref{eq:lognormal} with constant volatility.
  \item The probabilites are normalized by the sum of all probabilites
  \item The square root is applied and resulting numbers initialized in a quantum state.
\end{itemize} 
The algorithm for the distribution loading can then be implemented like:
\begin{lstlisting}
  def logNormalDistribution(num_qubits, mu, sigma, bounds: tuple, name):
    qc = QuantumCircuit(num_qubits, name=name)
    x = np.linspace(bounds[0], bounds[1], num=2**num_qubits)
    probabilities = []
    for x_i in x:
        # map probabilities from normal to log-normal reference:
        # https://stats.stackexchange.com/questions/214997/multivariate-log-normal-probabiltiy-density-function-pdf
        if np.min(x_i) > 0:
            det = 1 / np.prod(x_i)
            probability = multivariate_normal.pdf(np.log(x_i), mu, sigma) * det
        else:
            probability = 0
        probabilities += [probability]
        normalized_probabilities = probabilities / np.sum(probabilities) 
        
    initialize = Initialize(np.sqrt(normalized_probabilities))
    circuit = initialize.gates_to_uncompute().inverse()
    qc.compose(circuit, inplace=True)
    return qc, x, probabilities
\end{lstlisting}
In terms of a quantum state the above algorithm implements
\begin{equation}\label{eq:distLoading}
\ket{{\Phi}_n} = \sum_{i=0}^{2^n-1} \sqrt{p_i} \ket{S_i}_n .
\end{equation}


\subsubsection{Constructing the payoff}\label{sec:ConstructPayOff}
The payoff of a european call option at maturity is defined as 
\begin{equation}\label{eq:callPayoff}
  f(S_T) = \max \{ 0, S_T - K \},
\end{equation}
with $K$ the strike price and $T$ the maturity date. Numerically the payoff (and any other function) can be realized using piecewise linear functions for $S_T < K$ and $S_T \geq K$ which are dependent on the given stock price $S_i$. On a quantum computer we are interested in an operator
\begin{align}\label{eq:payOffOperator}
  f(i) &= \alpha i + \beta \\
  \ket{i}_n \ket{0} &\rightarrow \ket{i}_n (\text{cos}[f(i)] \ket{0} + \text{sin}[f(i)\ket{1}]),
\end{align}
where $f:\{ 0,...,2^n-1 \} \rightarrow [0,1]$. $f$ is on a quantum computer dependent on the stock price encoded in a quantum state and the piecewise linear functions are implemented usind controlled Y-gates.\\
\ref{payOffOperator} uses therefore the strategy introduced already in equation \ref{eq:estimate_a} to obtain the operator $A$ defined in \ref{eq:A_with_a}.
$f(i)$ is implemented by using each qubit $i$ of the $\ket{i}_n$(N) register as a control for the Y-rotation with angle $2^i \alpha $ of an ancilla qubit.
The constant term is implemented by an initial rotation on the ancilla without controls. 


\begin{figure}[H]
  \begin{center}
\begin{quantikz}
\lstick{\ket{q_0}} & \qw & \ctrl{3} & \qw & \qw & \qw\\
\lstick{\ket{q_1}} & \qw & \qw & \ctrl{2} & \qw & \qw\\
\lstick{\ket{q_2}} & \qw & \qw & \qw & \ctrl{1} & \qw\\
\lstick{\ket{q_3}} & \gate[1]{R_y(f_0)} & \gate[1]{CR_y(f_1)} & \gate[1]{2CR_y(f_1)} & \gate[1]{4CR_y(f_1)} & \qw
\end{quantikz}
\end{center}
\caption{ Quantum circuit that creates state in Eq. [\ref{eq:payOffOperator}].
Three qubits $\ket{i_2 i_1 i_0} $ are here used to be encode $i = 4 i_2 + 2i_1 + i_0 \in \{ 0,...,7 \}$. 
The linear function $f(i) = \alpha \cdot i + \beta$ is given by $4\alpha \cdot i_2 + 2 \alpha \cdot i_1  + \alpha \cdot i_0 + \beta$ .}
\label{fig:PF_y}
\end{figure}


Equation \ref{eq:payOffOperator} can be used to create the operator that maps $\sum_i \sqrt{p_i} \ket{i}_n \ket{0}$ to
\begin{equation}\label{eq:mappedPayoffOperator}
  \sum_{i=0}^{2^n-1} \sqrt{p_i} \ket{i}_n \bigl[ \text{cos}( f_c \cdot \hat{f}(i) + \frac{\pi}{4}) \ket{0} +
   \text{sin} (f_c \cdot \hat{f}(i) + \frac{\pi}{4}) \ket{1} \bigr],
\end{equation}
with $f_c \in [ 0,1 ]$. \\
$f(i)$ is of course only a mapped payoff since the payoff is usually defined on closed intervals
\begin{equation}\label{eq:linFuncBoundPayoff}
  f: [ a,b ] \rightarrow [ c,d ].
\end{equation}
For the introduced piece-wise representation of the payoff we already used the domain and image suitable for calculations on a quantum computer
\begin{equation}\label{eq:hatLinFuncPayoff}
  \hat{f}: \{0,...,2^n-1 \} \rightarrow [ 0,1 ].
\end{equation}.
Hence it is necessary to introduce an affine transformation to realize the transition between \ref{eq:linFuncBoundPayoff} and \ref{eq:hatLinFuncPayoff}
\begin{align}\label{eq:affinTransformPayoff}
  \phi(x) &= a + \frac{b-a}{2^n-1} \cdot x \\
  \hat{f}(x) &= \frac{f(\phi(x))-c}{d-c}.
\end{align}
Consequently , $\sin^2 [f_c \cdot \hat{f}(i) + \pi/4 ] $ is an anti-symmetric function around $1/2$ and mimicks a linear behavior on $[0,1]$.
With $\hat{f}(i)$ now being set into \ref{eq:mappedPayoffOperator} the probability to find the ancilla qubit in state $\ket{1}$,
\begin{equation}\label{eq:probability1MappedLinFunc}
  P_1 = \sum_{i=0}^{2^n-1} p_i \sin^2(f_c \cdot \hat{f}(i) + \frac{\pi}{4}), 
\end{equation}
is well approximated by 
\begin{equation}\label{eq:approxP1}
  P_1 \approx \sum_{i=0}^{2^n-1} p_i \bigl( f_c \cdot \hat{f}(i) + 1/2 \bigr) = f_c \frac{E[ f(x) ] - c}{d-c} - f_c + \frac{1}{2}.
\end{equation}
The approximation is obtained by making use of the following Taylor expansion
\begin{equation}\label{eq:sinTaylor}
  \sin^2(c \hat{f}(i) + \frac{\pi}{4}) = f_c \hat{f}(i) + \frac{1}{2} + \mathcal{O}(f_c^3 \hat{f}^3(i)),
\end{equation}
which is valid for small values of $ f_c \hat{f}(i) $.\\
From \ref{eq:approxP1} $E(f(x))$ can be recovered since Quantum Amplitude Estimation allow to efficiently estimate $P_1$ and because $c, d$ and $f_c$
are known.


\subsubsection{Implementation of max-function}\label{sec:ImplMaxFunc}

Mimicking the linear behavior of the payoff is done by the approach outlined in Sec. \ref{sec:ConstructPayOff}, but still a way to express the max operation
on a quantum computer is missing. In the following one approach is shown by comparision between the values encoded in the basis states of Eq. \ref{eq:distLoading}.\\
In principle we use $n$ additional ancilla qubits $\ket{a}$ in addition to the already given $n$ data qubits in the $\ket{i}$-register to build a greater-equal operation.
\begin{enumerate}
  \item Convert the breakpoint of piece-wise linear function $b \in [0,2^n-1]$ in bit representation $t$. The breakpoint indicates the threshold from which a actuall payoff is gained and is therefore equal to the strike price $K$.
  To prevent the breakpoint from lying in between two grid points a ceil operation is applied on $b$ to set it to next grid point before the conversion is done. During the conversion every qubit is represented by a bit.
  \item Iterate over all qubits ($j$ is used as iteration parameter)
  \begin{itemize}
    \item if $j=0$ and $t[j]=1$, perform a $CX$ operation on $\ket{q_j}$ and $\ket{a_j}$.
    \item if $t[j]=1$ an $OR$-Operation has to be applied to $\ket{q_j}$ and $\ket{a_{j-1}}$ and save the result of the $OR$-Operation in $\ket{a_j}$
    \item if $t[j]=0$ an $CCX$-Operation has to be applied to $\ket{q_j}$, $\ket{a_{j-1}}$ and $\ket{a_j}$
  \end{itemize}
  \item $\ket{a_{n-1}}$ is now $\ket{0}$ if $i<b$ and $\ket{1}$ if $i\geq b$ and therefore a quantum version of a max-function.
  \item Reverse the process by simply applying the complex conjugate of all operations except for the last qubit which does store the outcome of max-operation.
\end{enumerate}
\begin{figure}[H]
  \begin{center}
\begin{quantikz}
 & & & & &  & & & & & & &  \gategroup[9,steps=7,style={dashed,rounded corners,fill=blue!20, inner xsep=2pt},background]{{Inverse for n-2 to 0}}    & & & &  &  &    \\
\lstick{\ket{i_0}} & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}]{{t[0]=1}} & \qw & \qw & \qw & \qw & \qw  & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}]{{t[0]=1}} & \qw  \\
\lstick{\ket{i_1}} & \qw & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}, label style={label position=below,anchor=north,yshift=-0.2cm}]{{t[1]=0}} & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}, label style={label position=below,anchor=north,yshift=-0.2cm}]{{t[1]=1}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}, label style={label position=below,anchor=north,yshift=-0.2cm}]{{t[1]=0}} & \qw & \ctrl{4}\gategroup[5,steps=1,style={dashed,rounded corners, inner xsep=2pt}, label style={label position=below,anchor=north,yshift=-0.2cm}]{{t[1]=1}} & \qw & \qw & \qw \\
\lstick{\vdots} & & & &  & & \vdots & & & & & \vdots & & & & &  &  &    \\
\lstick{\ket{i_{n-1}}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{4}\gategroup[6,steps=1,style={dashed,rounded corners, inner xsep=2pt}]{{t[n-1]=0}} & \qw & \ctrl{4}\gategroup[6,steps=1,style={dashed,rounded corners, inner xsep=2pt}]{{t[n-1]=1}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw \\
\lstick{\ket{a_0}} & \targ{} & \qw & \ctrl{1} & \qw & \ctrl{1} & \qw & \qw & \qw & \qw & \qw  & \qw & \qw & \qw & \qw & \qw & \qw & \targ{} & \qw   \\
\lstick{\ket{a_1}} & \qw & \qw & \targ{} & \qw & \gate{OR} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \targ{} & \qw & \gate[style={fill=blue!20}]{OR} & \qw & \qw & \qw \\
\lstick{\vdots} & & & & & & \vdots & & & & & \vdots & & & &  & &  & \\
\lstick{\ket{a_{n-2}}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{1} & \qw & \ctrl{1} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \qw \\
\lstick{\ket{a_{n-1}}} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \targ{} & \qw & \gate{OR} & \qw & \qw & \qw & \qw & \qw  & \qw & \qw & \qw 
\end{quantikz}
\end{center}
\caption{ Quantum comparator for implementing a quantum version of max-function. Depending on strike price $K$ and stock price stored in $\ket{i}_n$ information
if stock price is greater than strike price is stored in last qubit $\ket{a}_{n-1}$. State of $\ket{a}_{n-1}$ is then kept for usage in later stage of circuit whereas
rest of the circuit is inverted for next stock price.}
\label{fig:PF_max}
\end{figure}

\begin{lstlisting}[caption={Implementation of quantum comparator as described in section \ref{sec:ImplMaxFunc}},captionpos=b]
  def qubit_integer_comparator(num_qubits_dist, compare_value, bigger_then=True ,name="compare_{value:.2f}_{bit_value}"):
  qubits_dist = list(range(num_qubits_dist))
  qubits_compare = list(range(num_qubits_dist, num_qubits_A*2))
  bin_compare_value = value_to_binar(compare_value, num_qubits_dist)
  num_qubits_all = num_qubits_dist*2
  num_qubits_compare = len(qubits_compare)
  comparator = QuantumCircuit(num_qubits_all)
  if compare_value <= 0:  # condition always satisfied for non-positive values
      if bigger_then:  # otherwise the condition is never satisfied
          comparator.x(qubits_compare[0])
      # condition never satisfied for values larger than or equal to 2^n
  elif compare_value < pow(2, num_qubits_dist):
      if num_qubits_dist > 1:
          for i in range(num_qubits_dist):
              if i == 0:
                  if bin_compare_value[i] == 1:
                      comparator.cx(qubits_dist[i], qubits_compare[i+1])
              elif i < num_qubits_dist - 1:
                  if bin_compare_value[i] == 1:
                      comparator.compose(OR(2), [qubits_dist[i], qubits_compare[i], qubits_compare[i + 1]], inplace=True)
                  else:
                      comparator.ccx(qubits_dist[i], qubits_compare[i], qubits_compare[i + 1])
              else:
                  if bin_compare_value[i] == 1:
                      # OR needs the result argument as qubit not register, thus
                      # access the index [0]
                      comparator.compose(OR(2), [qubits_dist[i], qubits_compare[i], qubits_compare[0]], inplace=True)
                  else:
                      comparator.ccx(qubits_dist[i], qubits_compare[i], qubits_compare[0])
          # flip result bit if geq flag is false
          if not bigger_then:
              comparator.x(qubits_compare[0])
          # uncompute ancillas state
          for i in reversed(range(num_qubits_dist - 1)):
              if i == 0:
                  if bin_compare_value[i] == 1:
                      comparator.cx(qubits_dist[i], qubits_compare[i+1])
              else:
                  if bin_compare_value[i] == 1:
                      comparator.compose(OR(2), [qubits_dist[i], qubits_compare[i], qubits_compare[i+1]], inplace=True)
                  else:
                      comparator.ccx(qubits_dist[i], qubits_compare[i], qubits_compare[i+1])
      else:
          # num_state_qubits == 1 and value == 1:
          comparator.cx(qubits_dist[0], qubits_compare[0])
          # flip result bit if geq flag is false
          if not bigger_then:
              comparator.x(qubits_compare[0])
  else:
      if not bigger_then:  # otherwise the condition is never satisfied
          comparator.x(qubits_compare[0])
  comparator.name = name.format(value=compare_value, bit_value="".join(str(x) for x in bin_compare_value))
  return comparator
\end{lstlisting}

\subsubsection{Implementation of piece-wise linear functions}\label{sec:ImplPieceFunc}

Implementing the piecewise linear function is not directly straigth forward so a detailed introduction is given in the following. 
As mentioned above we are dealing with linear function to encode the payoff
\begin{equation}\label{eq:defLinearFunc}
  f(x) = \alpha x + \beta,
\end{equation}
where $f(x)$ maps $x$ to the payoff by equation \ref{eq:callPayoff} and the domain of $x$ consist of of two linear function. One for $S_T < K$ and one for $S_T \geq K$. 
Furthermore the $S_i$ do not occure as a real number but as an element of $\{ 0,...,2^n-1 \}$ and additionally on a quantum computer $f(x)$ has to be realised
using rotations in the corresponding Hilbert space. 
These challenges require us to use a affine mapping $\hat{f}(x)$ which is in contrast to
\begin{equation}\label{eq:linFuncBound}
  f: [ a,b ] \rightarrow [ c,d ]
\end{equation}
defined as
\begin{equation}\label{eq:hatLinFunc}
  \hat{f}: \{0,...,2^n-1 \} \rightarrow [ 0,1 ].
\end{equation}
Note that in this case $d=b-K$ thanks to the definition of the payoff. But how is the transformation from \ref{linFuncBound}
to \ref{eq:hatLinFunc} actually done?\\
For piecewise function there are of course breakpoints needed within $\{ 0,...,2^n-1 \}$
\begin{equation}\label{eq:breakpoints}
b_p(x) = \frac{x-a}{b-a} \times 2^n-1.
\end{equation}
In case of the payoff only one breakpoint is given for $ S_T \geq K $.
The affine transformation from $f$ to $\hat{f}$ is then
\begin{align}\label{eq:affinTransform}
  \phi(x) &= a + \frac{b-a}{2^n-1} \cdot x \\
  \hat{f}(x) &= \frac{f(\phi(x))-c}{d-c},
\end{align}
which already have been introduced in Section \ref{sec:ConstructPayOff}.\\
Implemented is $\phi(x)$ first by leveraging on the slope and offset of a linear function
\begin{align}\label{eq:mappedSlopeOffset}
  \hat{\alpha} &= \frac{\alpha}{2^n-1} \cdot (b-a)\\
  \hat{\beta} &= \beta\\
  &\Rightarrow \frac{\alpha}{2^n-1} \cdot (b-a) + \beta.
\end{align}
$\hat{f}(x)$ is then generated by introducing the slope and offset angles
\begin{align}\label{eq:affineAngles}
  \theta_{\hat{\alpha}} &= \frac{\pi}{2}f_c\frac{\alpha}{2^n-1}\frac{b-a}{d-c}\\
  \theta_{\hat{\beta}} &=\frac{\pi}{4}(1-f_c) + \frac{\pi}{2}\frac{\beta-c}{d-c}f_c,
\end{align}
where $\pi/2$ is used to map from slope and offest to angles. $f_c$ is here again the factor for taylor approximation, introduced in \ref{eq:approxP1}.\\
Note here that the rotations using the angles above are realized on a Quantum Computer using $R_Y$-Gates
and the inset of a slope, i.e. rotations around the slope-angle $\theta_{\hat{\alpha}}$ is controlled by the last qubit of the quantum comparator
as explained in the previous section.\\
Furthermore and again thanks to the fact that we are dealing with a vector in a complex Hilbert space the actual used angle for implementing offset and slope
based on the given state in register $\ket{i}_n$ is finally computed using the following equations
\begin{align}
\theta_{\text{slope}}[b_p] &= \theta_{\hat{\alpha}}^{b_p} - \sum_{i=0}^{N_{b_p} - 1}\theta_{\hat{\alpha}}^{i} \label{eq:finalAngle} \\
\theta_{\text{offset}}[b_p] &= \theta_{\hat{\beta}}^{b_p} - \theta_{\hat{\alpha}} \cdot b_p - \sum_{i=0}^{N_{b_p} - 1}\theta_{\hat{\beta}}^{i} \label{eq:finalOffest}.
\end{align}
Hence the angles which have already been used for rotating the current state are substracted from the final slope angle $\theta_{\text{slope}}[b_p]$
This is realized through the summation to the last breakpoint $N_{b_p} - 1$. The additional term in the offset $ - \theta_{\hat{\alpha}} \cdot b_p$ is coming from the fact that the payoff
requires us to substract the strike price from the current stock price, see Equation \ref{eq:callPayoff}.\\
\begin{lstlisting}[caption={Implementation of payoff piecewise-linear function as described in section \ref{sec:ImplPieceFunc}},captionpos=b]
  def create_lin_circuit(offset, slope, num_qubits_dist, num_qubits_linear, name="lin-func"):
    linear_model = QuantumCircuit(num_qubits_dist+num_qubits_linear)
    linear_model.ry(offset, num_qubits_dist)
    for j, q_j in enumerate(range(num_qubits_dist)):
        linear_model.cry(slope * pow(2, j), q_j, num_qubits_dist)
    linear_model.name = name
    return linear_model

  def payoff_european(normal_dist_model, num_qubits_A, low, high, strike_price):
    high_number_qubit = 2**(num_qubits_A)-1
    f_min = 0
    f_max = normal_dist_model_custom[1][-1] - strike_price
    f_c = 0.25
    breakpoints = [low, strike_price]
    slopes = [0,1]
    offsets = [0,0]
    breakpoints = [(x-low) / (high-low) * (high_number_qubit) for x in breakpoints]
    slopes_temp = [2 * np.pi/2 * f_c * slope * (high-low)/high_number_qubit/(f_max-f_min) for slope in slopes]
    offsets_temp = [2 * np.pi / 4 * (1 - f_c) + np.pi/2 * f_c * (offset-f_min)/(f_max-f_min) for offset in offsets]
    slopes = np.zeros_like(slopes_temp)
    for i, slope in enumerate(slopes_temp):
        slopes[i] = slope - sum(slopes[:i])
    offsets = np.zeros_like(offsets_temp)
    for i, (offset, slope, point) in enumerate(zip(offsets_temp, slopes_temp, breakpoints)):
        offsets[i] = offset - slope * point - sum(offsets[:i])
    qubits_dist = list(range(num_qubits_A))
    qubits_linear = [num_qubits_A]
    qubits_compare = list(range(num_qubits_A+1, num_qubits_A*2+1))
    num_qubits_all = num_qubits_A*2+1
    num_qubits_linear = len(qubits_linear)
    num_qubits_compare = len(qubits_compare)
    payoff_model = QuantumCircuit(num_qubits_all, name="Payoff")
    for i, point in enumerate(breakpoints):
        linear_model = create_lin_circuit(offsets[i], slopes[i], num_qubits_A, num_qubits_linear, name="lin({:.2f})".format(point))
        if i == 0 and point == 0:
            payoff_model.append(linear_model.to_gate(), qubits_dist[:] + qubits_linear)
        else:
            comparator = qubit_integer_comparator(num_qubits_A, point)
            payoff_model.append(comparator.to_gate(), qubits_dist[:] + qubits_compare[:])
            payoff_model.append(linear_model.to_gate().control(), [qubits_compare[0]] + qubits_dist[:] + qubits_linear)
            payoff_model.append(comparator.to_gate().inverse(), qubits_dist[:] + qubits_compare[:])
    return payoff_model
\end{lstlisting}

\subsubsection{Estimating the expected payoff}
Putting all togehter the estimation of payoff is calculated using the following scheme:
\begin{itemize}
  \item First the initial probability distribution of stock prices is loaded into a quantum register $\ket{i}$ using
  the algorithmn described in \ref{sec:loadingDist}. The number of qubits $2^n-1$ determines how many different stock prices can be loaded into the grid represented by the quantum states.
  \item Second the quantum comparator is used on each stock price $ket{S_i}$ which is now equipped with the corresponding probability $\sqrt{p_i}$. $c$ additional ancilla qubits are needed next to the already given qubits in $\ket{i}$.
  The comparator applies the operation described in \ref{sec:ImplMaxFunc} and stores the outcome in the last qubit, which is then used to apply a slope to the linear payoff-function.
  \item Viewing the payoff as a piecewise-linear function Y-rotations are applied to the register $\ket{i}$. If the current stock-price is below the strike price (realized as a breakpoint of piecwise-linear function)
  then only the offset is used to rotate the state. If the current stock price is above the strike price, then additional rotations are applied to add a slope to the function. Since we are working with a quantum computer we need a affine transformation
  to map domain and image to suitable intervals. The realization of piecewise-linear function can be found in \ref{sec:ConstructPayOff}. The last three steps are then combined in a circuit A.
  \item The circuit A can then be used for amplitude amplification explained in \ref{sec:amplitudeAmplification} and amlitude estimation in turn to estimate $P_1$ (Eq. \ref{eq:approxP1} in combination with Eq. \ref{eq:estimate_a}) using Quantum Phase Estimation from Section \ref{sec:QPE}.
  \item As outlined in Eq. \ref{eq:approxP1} as a last step after computing $P_1$ a post procssing has to be applied which undos all scaling applied during the affine transformation: 
  \begin{equation}
     E[f(x)]  = ( E[\hat{f}(x)] - \frac{1}{2} + \frac{\pi}{4}f_c ) \frac{2}{\pi f_c} (d-c) + c
  \end{equation}
\end{itemize}
\biblio
\end{document}